%{

#include "tc.tab.hpp"

#include <cstdio>

#include <iostream>
#include <string>

extern "C" int yylex();
extern "C" FILE *yyin;

void yyerror(const char *s);

static TreeBuilder *tb;

%}

%code requires
{
#include "TreeBuilder.hpp"
#define YYLTYPE Location
}

%code provides
{
    #include <ostream>

    static std::ostream &
    operator<<(std::ostream &os, Text text)
    {
        os << '(' << text.from << ";+" << text.len << ')';
        return os;
    }
}

%locations

%union {
    Text text;
    PNode *node;
}

%token <text> ID NUM RETURN ';' '(' ')' '{' '}'

%type <node> tu funcs func stmts head body type name id args ret

%%

tu
    : funcs { tb->setRoot(tb->addNode($1, @1)); }
    ;

funcs
    : func       { $$ = tb->addNode($1, @1); }
    | funcs func { $$ = tb->append($1, tb->addNode($2, @2)); }
    ;

func
    : head body { $$ = tb->append($1, tb->addNode($2, @2)); }
    ;

body
    : '{' stmts '}' { $$ = tb->addNode({ tb->addNode($1, @1), tb->addNode($2, @2), tb->addNode($3, @3) }); }
    ;

stmts
    : /* empty */ { $$ = tb->addNode(); }
    | stmts ret   { $$ = tb->append($1, tb->addNode($2, @2)); }
    ;

head
    : type name args { $$ = tb->addNode({ tb->addNode($1, @1), tb->addNode($2, @2), tb->addNode($3, @3) }); }
    ;

type
    : id { $$ = tb->addNode($1, @1); }
    ;

name
    : id { $$ = tb->addNode($1, @1); }
    ;

id
    : ID { $$ = tb->addNode($1, @1); }
    ;

args
    : '(' ')' { $$ = tb->addNode({ tb->addNode($1, @1), tb->addNode($2, @2) }); }
    ;

ret
    : RETURN ';' { $$ = tb->addNode({ tb->addNode($1, @1), tb->addNode($2, @2) }); }
    | RETURN NUM ';' { $$ = tb->addNode({ tb->addNode($1, @1), tb->addNode($2, @2), tb->addNode($3, @3) }); }
    ;

%%


TreeBuilder
parse(const std::string &contents)
{
    extern std::size_t yyoffset;
    yyoffset = 0U;
    extern std::size_t yyline;
    yyline = 1U;
    extern std::size_t yycolumn;
    yycolumn = 1U;
    extern int yydebug;
    yydebug = 0;

    TreeBuilder tb;
    ::tb = &tb;

    FILE *myfile = fmemopen(const_cast<char *>(contents.data()),
                            contents.size(), "r");
    if (!myfile) {
        std::cerr << "I can't open the stream!\n";
        return tb;
    }
    // set flex to read from it instead of defaulting to STDIN:
    yyin = myfile;

    // parse through the input until there is no more:
    do {
        yyparse();
    } while (!std::feof(yyin));

    fclose(myfile);

    return tb;
}

void
yyerror(const char s[])
{
    std::cout << "EEK, parse error!  Message: " << s << std::endl;
    // might as well halt now:
    std::exit(-1);
}
